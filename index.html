<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>å­¸é•·ï¼Œåˆé¤åƒä»€éº¼ï¼Ÿ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- å­—é«” -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-card: rgba(255, 255, 255, 0.25);
      --button-bg: rgba(255, 255, 255, 0.25);
      --accent: #fbbf60;
      --text-main: #111827;
      --text-sub: #4b5563;
      --border-soft: rgba(255, 255, 255, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Noto Sans TC", system-ui, sans-serif;
      color: var(--text-main);
      min-height: 100vh;
      background: url("background.jpg") center/cover no-repeat fixed;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      z-index: -1;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: blur(18px);
      background: rgba(15,23,42,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.25);
      color: #f9fafb;
    }

    .nav {
      max-width: 960px;
      margin: 0 auto;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .nav-title {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .nav-sub {
      font-size: 0.8rem;
      color: #e5e7eb;
    }

    .nav-right {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .location-pill {
      border-radius: 999px;
      padding: 4px 12px;
      border: 1px solid rgba(248,250,252,0.7);
      background: rgba(15,23,42,0.6);
      font-size: 0.8rem;
      max-width: 260px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    main {
      max-width: 960px;
      margin: 0 auto;
      padding: 24px 16px 32px;
    }

    .card {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      border-radius: 22px;
      border: 1px solid var(--border-soft);
      padding: 20px 18px 18px;
      margin-bottom: 18px;
    }

    .card-title {
      font-size: 1.1rem;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .card-sub {
      font-size: 0.8rem;
      color: var(--text-sub);
    }

    .modes {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .mode-row {
      border-bottom: 1px dashed rgba(255,255,255,0.4);
      padding-bottom: 10px;
    }
    .mode-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .mode-header {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .mode-btn {
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.6);
      background: var(--button-bg);
      padding: 7px 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .mode-btn:hover {
      background: rgba(255,255,255,0.45);
    }

    .mode-btn span.emoji {
      font-size: 1.1rem;
    }

    .mode-chip-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .chip {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.7);
      background: rgba(255,255,255,0.3);
      font-size: 0.75rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .chip.active {
      background: #f9fafb;
      color: #111827;
      border-color: var(--accent);
      font-weight: 600;
    }

    .mode-select {
      margin-top: 6px;
      max-width: 360px;
      width: 100%;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.9);
      background: rgba(255,255,255,0.96);
      font-size: 0.8rem;
    }

    .mode-status {
      margin-top: 6px;
      font-size: 0.78rem;
      color: var(--text-sub);
    }

    .mode-status.error {
      color: #f97373;
      font-weight: 500;
    }

    .results-grid {
      margin-top: 8px;
      display: flex;
      gap: 10px;
      flex-wrap: nowrap;
    }

    .restaurant-card {
      flex: 1;
      min-width: 0;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(15,23,42,0.92);
      color: #f9fafb;
      padding: 8px;
      cursor: pointer;
      text-decoration: none;
      transition: 0.16s;
      display: block;
    }

    .restaurant-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.55);
      border-color: var(--accent);
    }

    .restaurant-img {
      width: 100%;
      height: 150px;
      border-radius: 10px;
      object-fit: cover;
      background: linear-gradient(135deg,#9a7b55,#463120);
      margin-bottom: 6px;
    }

    .restaurant-name {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .restaurant-addr {
      font-size: 0.76rem;
      color: #e5e7eb;
      min-height: 2.3em;
    }

    .restaurant-meta {
      margin-top: 4px;
      font-size: 0.72rem;
      display: flex;
      flex-wrap: wrap;
      gap: 4px 6px;
      align-items: center;
      justify-content: space-between;
    }

    .badge-open, .badge-closed, .badge-unknown {
      border-radius: 999px;
      padding: 1px 6px;
      border-width: 1px;
      border-style: solid;
      font-size: 0.7rem;
      white-space: nowrap;
    }

    .badge-open {
      background: rgba(34,197,94,0.2);
      border-color: rgba(34,197,94,0.7);
      color: #bbf7d0;
    }

    .badge-closed {
      background: rgba(248,113,113,0.2);
      border-color: rgba(248,113,113,0.85);
      color: #fecaca;
    }

    .badge-unknown {
      background: rgba(148,163,184,0.4);
      border-color: rgba(209,213,219,0.9);
      color: #e5e7eb;
    }

    .hint {
      margin-top: 8px;
      text-align: right;
      font-size: 0.74rem;
      color: var(--text-sub);
    }

    .daily-grid {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: nowrap;
    }

    .footer {
      text-align: center;
      font-size: 0.72rem;
      color: #e5e7eb;
      margin-top: 6px;
    }

    @media (max-width: 768px) {
      .results-grid, .daily-grid {
        flex-wrap: wrap;
      }
      .restaurant-card {
        width: 100%;
      }
      .nav {
        flex-direction: column;
        align-items: flex-start;
      }
      .nav-right {
        margin-left: 0;
      }
    }
  </style>

  <!-- Google Maps JSï¼ˆå« Geocoderï¼‰ -->
  <script>
    (g => {
      var h, a, k, p = "The Google Maps JavaScript API", c = "google",
        l = "importLibrary", q = "__ib__", m = document, b = window;
      b = b[c] || (b[c] = {});
      var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams;
      var u = () => h || (h = new Promise(async (f, n) => {
        await (a = m.createElement("script"));
        e.set("libraries", [...r] + "");
        for (k in g)
          e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]);
        e.set("callback", c + ".maps." + q);
        a.src = `https://maps.${c}apis.com/maps/api/js?` + e;
        d[q] = f;
        a.onerror = () => h = n(Error(p + " could not load."));
        a.nonce = m.querySelector("script[nonce]")?.nonce || "";
        m.head.append(a);
      }));
      d[l] ? console.warn(p + " only loads once. Ignoring:", g) :
        d[l] = (f, ...n) => (r.add(f), u().then(() => d[l](f, ...n)));
    })({
      key: "AIzaSyDsgevBWyNHGA7GJN9ENKINDRM2g5dBj1I",
      v: "weekly"
    });
  </script>
</head>

<body>
  <header>
    <div class="nav">
      <div>
        <div class="nav-title">å­¸é•·ï¼Œåˆé¤åƒä»€éº¼ï¼Ÿ</div>
        <div class="nav-sub">æ¯å¤©æŠ‰æ“‡é€™éº¼å¤šï¼Œè¦åƒä»€éº¼äº¤çµ¦æˆ‘</div>
      </div>
      <div class="nav-right">
        <div class="location-pill" id="locationPill">ç›®å‰ä½ç½®ï¼šå–å¾—ä¸­â€¦</div>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="card-title">ä»Šå¤©è¦åƒä»€éº¼ï¼Ÿï¼ˆéš¨æ©Ÿæ¨è–¦ï¼‰</div>
      <div class="card-sub">ä¾è·é›¢ç”±è¿‘åˆ°é ã€ç”±å·¦åˆ°å³å‘ˆç¾ã€‚</div>

      <div class="modes">

        <!-- å¾’æ­¥æ¨¡å¼ -->
        <div class="mode-row">
          <div class="mode-header">
            <button class="mode-btn" id="btnWalk">
              <span class="emoji">ğŸš¶â€â™€ï¸</span>
              <span>å¾’æ­¥æ¨¡å¼ï¼ˆ1 å…¬é‡Œå…§ï¼‰</span>
            </button>
          </div>
          <div class="mode-chip-row">
            <span class="chip" data-mode="walk" data-price="cheap">0â€“200 å…ƒ</span>
            <span class="chip" data-mode="walk" data-price="mid">200â€“400 å…ƒ</span>
            <span class="chip" data-mode="walk" data-price="expensive">400 å…ƒä»¥ä¸Š</span>
          </div>
          <select class="mode-select" id="walkCategory">
            <option value="">ä¸é™é¡å‹ï¼ˆéš¨æ©Ÿï¼‰</option>
            <option value="noodle">éºµé¡</option>
            <option value="rice">é£¯é¡</option>
            <option value="bento">ä¾¿ç•¶</option>
            <option value="bread">éºµåŒ…</option>
            <option value="chinese">ä¸­é¤</option>
            <option value="western">è¥¿é¤</option>
            <option value="italian">ç¾©å¤§åˆ©</option>
            <option value="indian">å°åº¦</option>
            <option value="turkish">åœŸè€³å…¶</option>
            <option value="arabic">é˜¿æ‹‰ä¼¯</option>
            <option value="love">åªæƒ³è¦æ„›æƒ… ğŸ’”</option>
          </select>
          <div class="mode-status" id="walkStatus"></div>
          <div class="results-grid" id="walkResults"></div>
        </div>

        <!-- é§•è»Šæ¨¡å¼ -->
        <div class="mode-row">
          <div class="mode-header">
            <button class="mode-btn" id="btnDrive">
              <span class="emoji">ğŸš—</span>
              <span>é§•è»Šæ¨¡å¼ï¼ˆ6 å…¬é‡Œå…§ï¼‰</span>
            </button>
          </div>
          <div class="mode-chip-row">
            <span class="chip" data-mode="drive" data-price="cheap">0â€“200 å…ƒ</span>
            <span class="chip" data-mode="drive" data-price="mid">200â€“400 å…ƒ</span>
            <span class="chip" data-mode="drive" data-price="expensive">400 å…ƒä»¥ä¸Š</span>
          </div>
          <select class="mode-select" id="driveCategory">
            <option value="">ä¸é™é¡å‹ï¼ˆéš¨æ©Ÿï¼‰</option>
            <option value="noodle">éºµé¡</option>
            <option value="rice">é£¯é¡</option>
            <option value="bento">ä¾¿ç•¶</option>
            <option value="bread">éºµåŒ…</option>
            <option value="chinese">ä¸­é¤</option>
            <option value="western">è¥¿é¤</option>
            <option value="italian">ç¾©å¤§åˆ©</option>
            <option value="indian">å°åº¦</option>
            <option value="turkish">åœŸè€³å…¶</option>
            <option value="arabic">é˜¿æ‹‰ä¼¯</option>
            <option value="love">åªæƒ³è¦æ„›æƒ… ğŸ’”</option>
          </select>
          <div class="mode-status" id="driveStatus"></div>
          <div class="results-grid" id="driveResults"></div>
        </div>

        <!-- åŸ·è¡Œæ¡ˆä»¶ -->
        <div class="mode-row">
          <div class="mode-header">
            <button class="mode-btn" id="btnDuty">
              <span class="emoji">ğŸš”</span>
              <span>åŸ·è¡Œæ¡ˆä»¶åƒä»€éº¼</span>
            </button>
          </div>
          <div class="mode-chip-row">
            <span class="chip" data-duty="breakfast">æ—©é¤</span>
            <span class="chip" data-duty="lunchdinner">åˆï¼æ™šé¤</span>
          </div>
          <div class="mode-status" id="dutyStatus"></div>
          <div class="results-grid" id="dutyResults"></div>
        </div>

        <!-- é£²æ–™æ¨¡å¼ -->
        <div class="mode-row">
          <div class="mode-header">
            <button class="mode-btn" id="btnDrink">
              <span class="emoji">ğŸ¥¤</span>
              <span>é£²æ–™å–ä»€éº¼ï¼Ÿï¼ˆ2 å…¬é‡Œå…§ï¼‰</span>
            </button>
          </div>
          <div class="mode-chip-row">
            <span class="chip" data-drink="bubble">ğŸ§‹ æ‰‹æ–é£²</span>
            <span class="chip" data-drink="cafe">â˜• å’–å•¡å»³</span>
          </div>
          <div class="mode-status" id="drinkStatus"></div>
          <div class="results-grid" id="drinkResults"></div>
        </div>

      </div>

      <div class="hint">é»å¡ç‰‡å³å¯é–‹å•Ÿ Google Maps å•†å®¶é é¢</div>
    </section>

    <!-- æ¯æ—¥ç²¾é¸ -->
    <section class="card">
      <div class="card-title">æ¯æ—¥ç²¾é¸</div>
      <div class="card-sub">ä¾ç›®å‰æ™‚é–“èˆ‡è·é›¢ï¼Œå¹«ä½ æŒ‘ä¸‰é–“é™„è¿‘é©åˆåƒæ­£é¤çš„åº—ã€‚</div>
      <div class="mode-status" id="dailyStatus">æ­£åœ¨å–å¾—ä½ç½®èˆ‡é™„è¿‘åº—å®¶â€¦</div>
      <div class="daily-grid" id="dailyResults"></div>
      <div class="hint">åŒæ¨£ä¾è·é›¢ç”±è¿‘åˆ°é å‘ˆç¾ã€‚</div>
    </section>

    <div class="footer">
      æœ¬é åƒ…æä¾›é¤é£²å»ºè­°ï¼Œå¯¦éš›è³‡è¨Šè«‹ä»¥åº—å®¶å…¬å‘Šç‚ºæº–ã€‚
    </div>
  </main>

  <script>
    const PLACES_API_KEY = "AIzaSyDsgevBWyNHGA7GJN9ENKINDRM2g5dBj1I";

    const WALK_RADIUS = 1000;
    const DRIVE_RADIUS = 6000;
    const DRINK_RADIUS = 2000;
    const DAILY_RADIUS = 2000;

    let geocoder;
    let userLocation = null;

    let recentWalkIds = [];
    let recentDriveIds = [];

    const locationPill = document.getElementById("locationPill");

    const walkStatus = document.getElementById("walkStatus");
    const walkResults = document.getElementById("walkResults");
    const driveStatus = document.getElementById("driveStatus");
    const driveResults = document.getElementById("driveResults");
    const dutyStatus = document.getElementById("dutyStatus");
    const dutyResults = document.getElementById("dutyResults");
    const drinkStatus = document.getElementById("drinkStatus");
    const drinkResults = document.getElementById("drinkResults");
    const dailyStatus = document.getElementById("dailyStatus");
    const dailyResults = document.getElementById("dailyResults");

    function deg2rad(d) { return d * Math.PI / 180; }
    function calcDistanceMeters(lat1, lng1, lat2, lng2) {
      const R = 6371000;
      const dLat = deg2rad(lat2 - lat1);
      const dLng = deg2rad(lng2 - lng1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLng / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }
    function formatDistance(m) {
      if (!m && m !== 0) return "è·é›¢æœªçŸ¥";
      if (m < 200) return `${Math.round(m)} å…¬å°º`;
      if (m < 1000) return `${Math.round(m / 10) * 10} å…¬å°º`;
      return `${(m / 1000).toFixed(1).replace(/\.0$/, "")} å…¬é‡Œ`;
    }
    function getOpenBadge(openNow) {
      if (openNow === true) return { text: "ç‡Ÿæ¥­ä¸­", cls: "badge-open" };
      if (openNow === false) return { text: "ä¼‘æ¯ä¸­", cls: "badge-closed" };
      return { text: "ç‡Ÿæ¥­æ™‚é–“æœªçŸ¥", cls: "badge-unknown" };
    }
    function priceLevelText(lvl) {
      if (lvl === null || lvl === undefined) return "åƒ¹æ ¼æœªçŸ¥";
      if (lvl <= 1) return "ç´„ 0â€“200 å…ƒ";
      if (lvl === 2) return "ç´„ 200â€“400 å…ƒ";
      return "ç´„ 400 å…ƒä»¥ä¸Š";
    }
    function buildMapsUrl(place) {
      if (place.id) {
        return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place.displayName || "")}&query_place_id=${encodeURIComponent(place.id)}`;
      }
      const q = encodeURIComponent(place.displayName || place.formattedAddress || "");
      return `https://www.google.com/maps/search/?api=1&query=${q}`;
    }
    function buildPhotoUrl(place) {
      if (!place.photos || !place.photos.length) return null;
      const name = place.photos[0].name;
      return `https://places.googleapis.com/v1/${name}/media?maxHeightPx=180&maxWidthPx=320&key=${PLACES_API_KEY}`;
    }
    function normalizePlace(p) {
      const loc = p.location || {};
      return {
        id: p.id || p.name || "",
        displayName: p.displayName?.text || p.displayName || p.name || "æœªå‘½ååº—å®¶",
        formattedAddress: p.formattedAddress || "",
        latitude: loc.latitude,
        longitude: loc.longitude,
        rating: p.rating ?? null,
        priceLevel: p.priceLevel ?? null,
        types: p.types || [],
        openNow: p.currentOpeningHours?.openNow,
        photos: p.photos || []
      };
    }

    /* ---- é£²æ–™åµæ¸¬é‚è¼¯ï¼ˆç…§ä½ åŸæœ¬æª”æ¡ˆçš„ç‰ˆæœ¬ï¼‰ ---- */

    const DRINK_WHITELIST_NAMES = [
      "å…«æ›œç¦¾èŒ¶",
      "å…«æ›œå’ŒèŒ¶",
      "å…«æ›œ ç¦¾èŒ¶",
      "å…«æ›œ",
      "è¿·å®¢å¤",
      "å¯ä¸å¯ç†Ÿæˆç´…èŒ¶",
      "æ¸…å¿ƒç¦å…¨"
    ];

    const DRINK_BRAND_KEYWORDS = [
      "50åµ", "50 lan", "äº”ååµ",
      "å¯ä¸å¯", "å¯ä¸å¯ç†Ÿæˆç´…èŒ¶", "kebuke",
      "æ¸…å¿ƒ", "æ¸…å¿ƒç¦å…¨",
      "cocoéƒ½å¯", "coco éƒ½å¯", "coco",
      "èŒ¶æ¹¯æœƒ", "tp tea",
      "è¿·å®¢å¤", "milksha",
      "éº»å¤", "éº»å¤èŒ¶åŠ", "macu",
      "èŒ¶ã®é­”æ‰‹", "èŒ¶ä¹‹é­”æ‰‹",
      "å¤§è‹‘å­",
      "comebuy", "come buy",
      "å…«æ›œ", "å…«æ›œå’ŒèŒ¶", "å…«æ›œç¦¾èŒ¶",
      "ä¸€èŠ³", "ä¸€èŠ³æ°´æœèŒ¶", "yifang",
      "è¬æ³¢", "è¬æ³¢å³¶å¶¼ç´…èŒ¶", "wanpo",
      "æ˜¥é™½èŒ¶äº‹", "chun yang",
      "ä¸¸ä½œ", "ä¸¸ä½œé£ŸèŒ¶",
      "çƒå¼„", "çƒå¼„åŸç”ŸèŒ¶é£²", "unocha",
      "æ¸…ç‰",
      "èŒ¶å·¥å» ",
      "å–«èŒ¶å°èˆ–",
      "é»‘ç³–çç ", "çç…®ä¸¹", "é»‘ç³–å ‚", "tiger sugar",
      "é»‘æ³·å ‚", "heilongtang"
    ];

    function isDrinkPlace(place) {
      const rawName = place.displayName || "";
      const nameLower = rawName.toLowerCase();
      const types = (place.types || []).map(t => t.toLowerCase());

      if (DRINK_WHITELIST_NAMES.some(n => rawName.includes(n))) {
        return true;
      }

      if (DRINK_BRAND_KEYWORDS.some(k =>
        rawName.includes(k) || nameLower.includes(k.toLowerCase())
      )) {
        return true;
      }

      const textKeywords = [
        "é£²æ–™", "æ‰‹æ–", "æ‰‹æ–é£²", "èŒ¶åŠ", "ç´…èŒ¶", "é’è‰èŒ¶", "é®®èŒ¶",
        "å¥¶èŒ¶", "çç ", "æ³¢éœ¸", "é’è›™æ’å¥¶",
        "æ°´æœèŒ¶", "æœèŒ¶", "å†°æ²™", "å¤šå¤š", "å†¬ç“œèŒ¶", "å†¬ç“œæª¸æª¬",
        "èŒ¶é£²", "èŒ¶èˆ–", "èŒ¶èˆ–å­"
      ];

      if (textKeywords.some(k => rawName.includes(k))) {
        return true;
      }

      const englishDrinkKeywords = [
        "tea", "milk tea", "bubble tea", "boba", "tapioca",
        "fruit tea", "ice tea", "iced tea", "smoothie", "juice"
      ];
      if (englishDrinkKeywords.some(k => nameLower.includes(k))) {
        return true;
      }

      const drinkTypes = ["cafe", "bar", "juice_bar"];
      if (drinkTypes.some(t => types.includes(t))) {
        return true;
      }

      return false;
    }

    function isPureLodging(place) {
      const rawName = place.displayName || "";
      const nameLower = rawName.toLowerCase();
      const types = (place.types || []).map(t => t.toLowerCase());

      const lodgingWords = [
        "é£¯åº—", "é…’åº—", "æ—…é¤¨", "æ—…åº—", "æ—…ç¤¾", "æ°‘å®¿", "å•†æ—…",
        "hotel", "motel", "hostel", "inn"
      ];
      const restaurantWords = [
        "é¤å»³", "é£Ÿå ‚", "å°åƒ", "æ‹‰éºµ", "æ‹‰éºº", "éºµé¤¨", "éºµåº—",
        "ç‰›æ’", "ç‡’è‚‰", "ä¸¼é£¯", "å’–å•¡", "æ—©åˆé¤", "æ—©é¤",
        "é‹", "ç«é‹", "å±…é…’å±‹", "bistro", "restaurant", "cafe",
        "pizza", "ramen", "burger", "steak"
      ];

      const hasLodgingType = types.includes("lodging");
      const hasRestaurantWord = restaurantWords.some(w => rawName.includes(w) || nameLower.includes(w.toLowerCase()));

      if (hasLodgingType && !hasRestaurantWord) return true;
      if (lodgingWords.some(w => rawName.includes(w) || nameLower.includes(w.toLowerCase()))) {
        if (!hasRestaurantWord) return true;
      }
      return false;
    }

    /* ---- æ‰‹æ– vs å’–å•¡å»³ç´°åˆ†ï¼ˆåœ¨ isDrinkPlace ä¹‹ä¸Šå†åˆ†æµï¼‰ ---- */

    const BUBBLE_KEYWORDS = [
      "é£²æ–™","æ‰‹æ–","æ‰‹æ–é£²","ç´…èŒ¶","å¥¶èŒ¶","é’èŒ¶","æ°´æœèŒ¶","æ³¢éœ¸","çç ","é’è›™æ’å¥¶",
      "æœèŒ¶","å†°æ²™","å†¬ç“œèŒ¶","å†¬ç“œæª¸æª¬","å¤šå¤š","èŒ¶é£²","èŒ¶åŠ","tea","milk tea","bubble tea","boba"
    ];
    const BUBBLE_BRANDS = DRINK_BRAND_KEYWORDS;

    const CAFE_KEYWORDS = [
      "å’–å•¡","coffee","cafe","cafÃ©","æ˜Ÿå·´å…‹","starbucks","è·¯æ˜“è","louisa",
      "cama","ä¼¯æœ—","mr. brown","ä¸¹å ¤","dante","æ—©åˆé¤","brunch"
    ];

    function isBubbleTeaPlace(place) {
      const name = (place.displayName || "").toLowerCase();
      if (BUBBLE_BRANDS.some(k => name.includes(k.toLowerCase()))) return true;
      if (BUBBLE_KEYWORDS.some(k => name.includes(k.toLowerCase()))) return true;
      return false;
    }
    function isCafePlace(place) {
      const name = (place.displayName || "").toLowerCase();
      if (CAFE_KEYWORDS.some(k => name.includes(k.toLowerCase()))) return true;
      const types = (place.types || []).map(t => t.toLowerCase());
      if (types.includes("cafe")) return true;
      return false;
    }

    async function placesSearchNearby({ center, radius, includedTypes }) {
      const body = {
        includedTypes,
        maxResultCount: 20,
        locationRestriction: {
          circle: {
            center: {
              latitude: center.lat,
              longitude: center.lng
            },
            radius
          }
        }
      };

      const res = await fetch("https://places.googleapis.com/v1/places:searchNearby", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Goog-Api-Key": PLACES_API_KEY,
          "X-Goog-FieldMask":
            "places.id,places.displayName,places.formattedAddress,places.location,places.rating,places.priceLevel,places.types,places.currentOpeningHours.openNow,places.photos"
        },
        body: JSON.stringify(body)
      });

      if (!res.ok) {
        console.error("Places nearby error", await res.text());
        throw new Error("Places API å›æ‡‰éŒ¯èª¤");
      }

      const data = await res.json();
      return (data.places || []).map(normalizePlace);
    }

    async function searchMealPlaces(radius) {
      const includedTypes = ["restaurant", "meal_takeaway"];
      const places = await placesSearchNearby({
        center: userLocation,
        radius,
        includedTypes
      });
      return places.filter(p => !isPureLodging(p));
    }
    async function searchDrinkPlaces(radius) {
      const includedTypes = ["restaurant","cafe","bar","meal_takeaway"];
      const places = await placesSearchNearby({
        center: userLocation,
        radius,
        includedTypes
      });
      return places.filter(p => !isPureLodging(p));
    }
    async function searchConvenienceStores(radius) {
      const includedTypes = ["convenience_store"];
      const places = await placesSearchNearby({
        center: userLocation,
        radius,
        includedTypes
      });
      return places;
    }

    function renderPlaces(listEl, places) {
      listEl.innerHTML = "";
      places.forEach(p => {
        const url = buildMapsUrl(p);
        const photoUrl = buildPhotoUrl(p);
        const dist = (p.latitude && p.longitude && userLocation)
          ? calcDistanceMeters(userLocation.lat, userLocation.lng, p.latitude, p.longitude)
          : null;
        const distText = formatDistance(dist);
        const badge = getOpenBadge(p.openNow);

        const a = document.createElement("a");
        a.href = url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.className = "restaurant-card";

        const img = document.createElement("img");
        img.className = "restaurant-img";
        img.alt = p.displayName;
        if (photoUrl) img.src = photoUrl;

        const nameDiv = document.createElement("div");
        nameDiv.className = "restaurant-name";
        nameDiv.textContent = p.displayName;

        const addrDiv = document.createElement("div");
        addrDiv.className = "restaurant-addr";
        addrDiv.textContent = p.formattedAddress || "";

        const meta = document.createElement("div");
        meta.className = "restaurant-meta";
        const ratingSpan = document.createElement("span");
        ratingSpan.textContent = p.rating ? `â­ ${p.rating.toFixed(1)}` : "å°šç„¡è©•åˆ†";
        const distSpan = document.createElement("span");
        distSpan.textContent = distText;
        const priceSpan = document.createElement("span");
        priceSpan.textContent = priceLevelText(p.priceLevel);
        const openSpan = document.createElement("span");
        openSpan.className = badge.cls;
        openSpan.textContent = badge.text;

        meta.appendChild(ratingSpan);
        meta.appendChild(distSpan);
        meta.appendChild(priceSpan);
        meta.appendChild(openSpan);

        a.appendChild(img);
        a.appendChild(nameDiv);
        a.appendChild(addrDiv);
        a.appendChild(meta);

        listEl.appendChild(a);
      });
    }

    function renderDutyPlaces(listEl, places) {
      listEl.innerHTML = "";
      places.forEach(p => {
        const a = document.createElement("a");
        a.href = p.url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.className = "restaurant-card";

        const img = document.createElement("div");
        img.className = "restaurant-img";

        const nameDiv = document.createElement("div");
        nameDiv.className = "restaurant-name";
        nameDiv.textContent = p.name;

        const addrDiv = document.createElement("div");
        addrDiv.className = "restaurant-addr";
        addrDiv.textContent = "é»æ“Šå¡ç‰‡å³å¯é–‹å•Ÿ Google Maps å°èˆª";

        const meta = document.createElement("div");
        meta.className = "restaurant-meta";
        meta.textContent = "å›ºå®šå£è¢‹åå–®";

        a.appendChild(img);
        a.appendChild(nameDiv);
        a.appendChild(addrDiv);
        a.appendChild(meta);

        listEl.appendChild(a);
      });
    }

    function getSelectedPriceKey(mode) {
      const chip = document.querySelector(`.chip.active[data-mode="${mode}"]`);
      return chip ? chip.dataset.price : null;
    }
    function filterByPriceKey(priceKey, place) {
      if (!priceKey) return true;
      const lvl = place.priceLevel;
      if (lvl === null || lvl === undefined) return true;
      if (priceKey === "cheap") return lvl <= 1;
      if (priceKey === "mid") return lvl === 2;
      if (priceKey === "expensive") return lvl >= 3;
      return true;
    }

    const CATEGORY_KEYWORD_MAP = {
      noodle: ["éºµ","æ‹‰éºµ","ç‰›è‚‰éºµ","æ¹¯éºµ","ä¹¾éºµ","ramen","noodle","noodles"],
      rice: ["é£¯","ç‚’é£¯","ç‡´é£¯","ç‡’è‡˜","æ»·è‚‰é£¯","é›è‚‰é£¯","rice"],
      bento: ["ä¾¿ç•¶","è‡ªåŠ©é¤","å¿«é¤","ç°¡é¤","bento"],
      bread: ["éºµåŒ…","çƒ˜ç„™","bakery","bread","toast","è›‹ç³•"],
      chinese: ["ä¸­å¼","å°åƒ","ç†±ç‚’","éºµåº—","é£¯é¤¨","chinese"],
      western: ["è¥¿å¼","ç¾©å¼","ç¾å¼","æ’é¤","æ¼¢å ¡","æŠ«è–©","æ—©åˆé¤","bistro","western"],
      italian: ["ç¾©å¤§åˆ©éºµ","ç¾©å¤§åˆ©","pasta","pizza","ç¾©å¼"],
      indian: ["å°åº¦","å’–å“©","å°åº¦å’–å“©","indian","curry","naan"],
      turkish: ["åœŸè€³å…¶","æ²™å¨ç‘ª","kebab","turkish"],
      arabic: ["é˜¿æ‹‰ä¼¯","ä¸­æ±æ–™ç†","arabic","middle east"]
    };

    function filterByCategoryKey(catKey, place) {
      if (!catKey) return true;
      if (catKey === "love") return true;
      const keywords = CATEGORY_KEYWORD_MAP[catKey];
      if (!keywords) return true;
      const name = (place.displayName || "").toLowerCase();
      const types = (place.types || []).map(t => t.toLowerCase());
      const isBakeryType = types.includes("bakery");
      if (catKey === "noodle" && isBakeryType) return false;
      return keywords.some(k => name.includes(k.toLowerCase())) ||
        (catKey === "bread" && isBakeryType);
    }

    function pickTieredPlaces(allPlaces, radius, ranges, recentIds, needCount = 3) {
      const withDist = allPlaces
        .filter(p => p.latitude && p.longitude)
        .map(p => ({
          ...p,
          _dist: calcDistanceMeters(userLocation.lat, userLocation.lng, p.latitude, p.longitude)
        }))
        .filter(p => p._dist <= radius);

      const picked = [];
      const used = new Set();
      const isRecent = id => recentIds.includes(id);

      for (const r of ranges) {
        if (picked.length >= needCount) break;

        const layer = withDist.filter(p => p._dist >= r.min && p._dist < r.max && !isRecent(p.id));

        let cand4 = layer.filter(p => (p.rating || 0) >= 4);
        cand4.sort((a,b) => a._dist - b._dist);
        for (const p of cand4) {
          if (picked.length >= needCount) break;
          if (used.has(p.id)) continue;
          picked.push(p);
          used.add(p.id);
        }
        if (picked.length >= needCount) break;

        let cand3 = layer.filter(p => (p.rating || 0) >= 3 && !used.has(p.id));
        cand3.sort((a,b) => a._dist - b._dist);
        for (const p of cand3) {
          if (picked.length >= needCount) break;
          if (used.has(p.id)) continue;
          picked.push(p);
          used.add(p.id);
        }
      }

      picked.sort((a,b) => a._dist - b._dist);
      return picked;
    }

    function updateRecentIds(arr, selected) {
      const newIds = selected.map(p => p.id).filter(Boolean);
      const set = new Set(newIds.concat(arr));
      const merged = Array.from(set);
      arr.length = 0;
      arr.push(...merged.slice(0, 8));
    }

    const DUTY_BREAKFAST = [
      { name: "å‡±ç³æ‰‹ä½œè›‹é¤…", url: "https://maps.app.goo.gl/uLm35ediiYf342D2A?g_st=ic" },
      { name: "å¤©æ©‹ä¸‹è±†æ¼¿ä¹‹å®¶", url: "https://maps.app.goo.gl/QCCtw1TE36HbgPf4A?g_st=ic" },
      { name: "é›…åŠ é”æ´»åŠ›æ—©é¤", url: "https://maps.app.goo.gl/uA2pkr7Rcnjq6L7J6?g_st=ic" },
      { name: "æœç¾æ–™", url: "https://maps.app.goo.gl/ZoHDT9J2v5Lpj7fc9?g_st=ic" },
      { name: "æ°¸å’Œè±†æ¼¿è€åº—", url: "https://maps.app.goo.gl/zX38DdpCbY1DKfoW7?g_st=ic" }
    ];
    const DUTY_LUNCH = [
      { name: "é³³å§ä¾¿ç•¶", url: "https://maps.app.goo.gl/nFqboF3uA48T4uW78?g_st=ic" },
      { name: "å»£å±…ç‡’è‡˜", url: "https://maps.app.goo.gl/bZTo4BbcmhKxu3iCA?g_st=ic" },
      { name: "é£¯é»è‡ªåŠ©é¤", url: "https://maps.app.goo.gl/9GYD6dcRWP5ev5Gb7?g_st=ic" },
      { name: "å‘³å®¶æ»·è‚‰é£¯", url: "https://maps.app.goo.gl/NseZfMkQm6AkdHu98?g_st=ic" },
      { name: "é‡‘ä»™æ»·è‚‰é£¯", url: "https://maps.app.goo.gl/1sZKEbAh1UQorKXq9?g_st=ic" },
      { name: "æ£®å°é¤¨", url: "https://maps.app.goo.gl/ZAF3dHgwTE3sMK7t8?g_st=ic" },
      { name: "æ¸¯éƒ½ç±³ç²‰æ¹¯", url: "https://maps.app.goo.gl/6fv53uNMqgv14LNT8?g_st=ic" },
      { name: "æ­£å¾·å°åƒåº—", url: "https://maps.app.goo.gl/FbtddJNwqMLYshWN7?g_st=ic" },
      { name: "å®¶åº­ç²¾ç·»è‡ªåŠ©é¤", url: "https://maps.app.goo.gl/nM1A85yueTUp9bEp9?g_st=ic" },
      { name: "å°é³³è»’", url: "https://maps.app.goo.gl/SHsiNnxtsNbNZPgq6?g_st=ic" }
    ];

    function shuffle(arr) {
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--) {
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }
    function detectDutyPeriodByTime() {
      const h = new Date().getHours();
      if (h >= 5 && h < 11) return "breakfast";
      return "lunchdinner";
    }
    function runDutyMode(explicitPeriod) {
      const period = explicitPeriod || detectDutyPeriodByTime();
      const list = period === "breakfast" ? DUTY_BREAKFAST : DUTY_LUNCH;
      const picked = shuffle(list).slice(0,3);
      dutyStatus.textContent = period === "breakfast"
        ? "ç¾åœ¨æ˜¯åŸ·è¡Œæ¡ˆä»¶ï¼šæ—©é¤å£è¢‹åå–®"
        : "ç¾åœ¨æ˜¯åŸ·è¡Œæ¡ˆä»¶ï¼šåˆï¼æ™šé¤å£è¢‹åå–®";
      renderDutyPlaces(dutyResults, picked);
    }

    function getSelectedDrinkTypes() {
      const chips = Array.from(document.querySelectorAll(".chip.active[data-drink]"));
      return chips.map(c => c.dataset.drink);
    }

    async function runDrinkMode() {
      if (!userLocation) {
        drinkStatus.textContent = "éœ€è¦å…ˆå–å¾—å®šä½æ‰èƒ½æ¨è–¦é£²æ–™ã€‚";
        drinkStatus.classList.add("error");
        drinkResults.innerHTML = "";
        return;
      }
      drinkStatus.classList.remove("error");
      drinkStatus.textContent = "æ­£åœ¨å¹«ä½ æ‰¾é™„è¿‘çš„é£²æ–™åº—â€¦";
      drinkResults.innerHTML = "";

      try {
        let places = await searchDrinkPlaces(DRINK_RADIUS);
        places = places.filter(p => p.openNow !== false && !isPureLodging(p));

        let withDist = places.map(p => ({
          ...p,
          _dist: (p.latitude && p.longitude)
            ? calcDistanceMeters(userLocation.lat, userLocation.lng, p.latitude, p.longitude)
            : Infinity
        }));

        // å…ˆç”¨ isDrinkPlace éæ¿¾å‡ºé£²æ–™åº— / å’–å•¡å»³
        const drinkCandidates = withDist.filter(isDrinkPlace);

        // å®Œå…¨æ²’æœ‰é£²æ–™åº— â†’ æ‰é€€åˆ°ä¾¿åˆ©å•†åº—
        if (drinkCandidates.length === 0) {
          drinkStatus.textContent = "é™„è¿‘æ‰¾ä¸åˆ°é£²æ–™åº—æˆ–å’–å•¡å»³ï¼Œæ”¹æ¨è–¦ä¾¿åˆ©å•†åº—çµ¦ä½ ã€‚";
          const stores = await searchConvenienceStores(DRINK_RADIUS);
          const withDistStore = stores.map(p => ({
            ...p,
            _dist: (p.latitude && p.longitude)
              ? calcDistanceMeters(userLocation.lat, userLocation.lng, p.latitude, p.longitude)
              : Infinity
          }));
          withDistStore.sort((a,b) => a._dist - b._dist);
          const storePick = withDistStore.slice(0,3);
          if (storePick.length === 0) {
            drinkStatus.classList.add("error");
            drinkStatus.textContent = "é™„è¿‘æ‰¾ä¸åˆ°é£²æ–™åº—æˆ–ä¾¿åˆ©å•†åº—ã€‚";
            drinkResults.innerHTML = "";
            return;
          }
          renderPlaces(drinkResults, storePick);
          return;
        }

        const bubbles = drinkCandidates.filter(isBubbleTeaPlace);
        const cafes = drinkCandidates.filter(isCafePlace);
        const drinkTypes = getSelectedDrinkTypes();

        let mode;
        if (drinkTypes.length === 1) mode = drinkTypes[0];      // bubble / cafe
        else if (drinkTypes.length >= 2) mode = "both";         // å…©ç¨®éƒ½æŠ½
        else mode = "bubbleFirst";                              // é è¨­ï¼šå„ªå…ˆæ‰‹æ–ï¼Œå…¶æ¬¡å’–å•¡å»³

        const sortFn = (a,b) => {
          if (a._dist !== b._dist) return a._dist - b._dist;
          const ar = a.rating || 0, br = b.rating || 0;
          return br - ar;
        };

        let baseList = [];
        let fallbackList = [];

        if (mode === "bubble") {
          baseList = bubbles;
          fallbackList = cafes;
          drinkStatus.textContent = "é€™æ¬¡å…ˆå¹«ä½ æŠ½æ‰‹æ–é£²ï¼ˆè·é›¢ç”±è¿‘åˆ°é ï¼‰ã€‚";
        } else if (mode === "cafe") {
          baseList = cafes;
          fallbackList = bubbles;
          drinkStatus.textContent = "é€™æ¬¡å…ˆå¹«ä½ æŠ½å’–å•¡å»³ï¼ˆè·é›¢ç”±è¿‘åˆ°é ï¼‰ã€‚";
        } else if (mode === "both") {
          const map = new Map();
          drinkCandidates.forEach(p => map.set(p.id, p));
          baseList = Array.from(map.values());
          fallbackList = [];
          drinkStatus.textContent = "åŒæ™‚å¾æ‰‹æ–èˆ‡å’–å•¡å»³è£¡æŠ½æœ€è¿‘çš„ä¸‰å®¶ã€‚";
        } else { // bubbleFirst
          if (bubbles.length > 0) {
            baseList = bubbles;
            fallbackList = cafes;
            drinkStatus.textContent = "å„ªå…ˆå¹«ä½ æ‰¾æ‰‹æ–é£²ï¼Œå…¶æ¬¡å’–å•¡å»³ã€‚";
          } else {
            baseList = cafes;
            fallbackList = [];
            drinkStatus.textContent = "é™„è¿‘æ‰‹æ–ä¸å¤šï¼Œå¹«ä½ æ”¹æ‰¾å’–å•¡å»³ã€‚";
          }
        }

        baseList.sort(sortFn);
        let picked = baseList.slice(0,3);

        if (picked.length < 3 && fallbackList.length) {
          fallbackList.sort(sortFn);
          const ids = new Set(picked.map(p => p.id));
          for (const p of fallbackList) {
            if (picked.length >= 3) break;
            if (ids.has(p.id)) continue;
            picked.push(p);
            ids.add(p.id);
          }
        }

        // å¦‚æœä»¥ä¸Šéƒ½æŠ½ä¸åˆ°ï¼Œå°±ç›´æ¥å¾ drinkCandidates è£¡æŒ‘æœ€è¿‘çš„ 3 é–“
        if (picked.length === 0) {
          drinkCandidates.sort(sortFn);
          picked = drinkCandidates.slice(0,3);
        }

        picked.sort((a,b) => a._dist - b._dist);
        drinkStatus.classList.remove("error");
        renderPlaces(drinkResults, picked);
      } catch (e) {
        console.error(e);
        drinkStatus.classList.add("error");
        drinkStatus.textContent = "é£²æ–™æ¨¡å¼æŸ¥è©¢å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
        drinkResults.innerHTML = "";
      }
    }

    async function runMealMode(mode) {
      const statusEl = mode === "walk" ? walkStatus : driveStatus;
      const resultsEl = mode === "walk" ? walkResults : driveResults;
      const radius = mode === "walk" ? WALK_RADIUS : DRIVE_RADIUS;
      const categorySelect = mode === "walk" ? document.getElementById("walkCategory") : document.getElementById("driveCategory");
      const recentIds = mode === "walk" ? recentWalkIds : recentDriveIds;

      if (!userLocation) {
        statusEl.textContent = "éœ€è¦å…ˆå–å¾—å®šä½æ‰èƒ½æ¨è–¦ã€‚";
        statusEl.classList.add("error");
        resultsEl.innerHTML = "";
        return;
      }

      statusEl.classList.remove("error");
      statusEl.textContent = "æ­£åœ¨å¹«ä½ æ‰¾é™„è¿‘çš„åº—å®¶â€¦";
      resultsEl.innerHTML = "";

      const category = categorySelect.value;
      if (category === "love") {
        statusEl.classList.add("error");
        statusEl.textContent = "é™„è¿‘æŸ¥ä¸åˆ°æ„›æƒ…ï¼Œåªèƒ½å…ˆå¡«é£½è‚šå­ ğŸ’”";
        resultsEl.innerHTML = "";
        return;
      }

      try {
        let places = await searchMealPlaces(radius);
        places = places.filter(p => filterByCategoryKey(category, p));
        const priceKey = getSelectedPriceKey(mode);
        places = places.filter(p => filterByPriceKey(priceKey, p));
        if (!places.length) {
          statusEl.classList.add("error");
          statusEl.textContent = "é™„è¿‘æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„é¤å»³ï¼Œè©¦è©¦æ”¾å¯¬æ¢ä»¶ã€‚";
          resultsEl.innerHTML = "";
          return;
        }

        const ranges = mode === "walk"
          ? [
              {min: 0, max: 300},
              {min: 300, max: 600},
              {min: 600, max: 1000}
            ]
          : [
              {min: 0, max: 1000},
              {min: 1000, max: 3000},
              {min: 3000, max: 6000}
            ];

        const picked = pickTieredPlaces(places, radius, ranges, recentIds, 3);
        if (picked.length === 0) {
          statusEl.classList.add("error");
          statusEl.textContent = "é™„è¿‘æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„é¤å»³ã€‚";
          resultsEl.innerHTML = "";
          return;
        }

        if (mode === "walk") updateRecentIds(recentWalkIds, picked);
        else updateRecentIds(recentDriveIds, picked);

        statusEl.classList.remove("error");
        statusEl.textContent = "å·²ä¾è·é›¢ç”±è¿‘åˆ°é å¹«ä½ æŒ‘å¥½ã€‚";
        renderPlaces(resultsEl, picked);
      } catch (e) {
        console.error(e);
        statusEl.classList.add("error");
        statusEl.textContent = "æŸ¥è©¢å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
        resultsEl.innerHTML = "";
      }
    }

    async function runDailyPicks() {
      if (!userLocation) {
        dailyStatus.textContent = "éœ€è¦å…ˆå–å¾—å®šä½æ‰æœ‰æ¯æ—¥ç²¾é¸ã€‚";
        return;
      }
      dailyStatus.textContent = "æ­£åœ¨è¼‰å…¥é™„è¿‘åº—å®¶â€¦";
      dailyResults.innerHTML = "";

      try {
        let places = await searchMealPlaces(DAILY_RADIUS);
        places = places.filter(p => p.openNow !== false);

        const withDist = places
          .filter(p => p.latitude && p.longitude)
          .map(p => ({
            ...p,
            _dist: calcDistanceMeters(userLocation.lat, userLocation.lng, p.latitude, p.longitude)
          }));

        withDist.sort((a,b) => {
          if (a._dist !== b._dist) return a._dist - b._dist;
          const ar = a.rating || 0, br = b.rating || 0;
          return br - ar;
        });

        const picked = withDist.slice(0,3);
        if (!picked.length) {
          dailyStatus.textContent = "é™„è¿‘æš«æ™‚æŸ¥ä¸åˆ°åˆé©çš„æ­£é¤åº—å®¶ã€‚";
          dailyResults.innerHTML = "";
          return;
        }
        dailyStatus.textContent = "";
        renderPlaces(dailyResults, picked);
      } catch (e) {
        console.error(e);
        dailyStatus.textContent = "æ¯æ—¥ç²¾é¸è¼‰å…¥å¤±æ•—ã€‚";
        dailyResults.innerHTML = "";
      }
    }

    async function initMapAndLocation() {
      const { Geocoder } = await google.maps.importLibrary("geocoding");
      geocoder = new Geocoder();

      if (!navigator.geolocation) {
        locationPill.textContent = "ç›®å‰ä½ç½®ï¼šæ­¤è£ç½®ä¸æ”¯æ´å®šä½";
        dailyStatus.textContent = "ç„¡æ³•å–å¾—å®šä½ï¼Œè«‹å…è¨±å®šä½å¾Œé‡æ–°æ•´ç†é é¢ã€‚";
        return;
      }

      locationPill.textContent = "ç›®å‰ä½ç½®ï¼šå–å¾—ä¸­â€¦";

      navigator.geolocation.getCurrentPosition(async (pos) => {
        userLocation = {
          lat: pos.coords.latitude,
          lng: pos.coords.longitude
        };
        try {
          const { results } = await geocoder.geocode({ location: userLocation });
          if (results && results[0]) {
            const addr = results[0].formatted_address || "å·²å–å¾—å®šä½";
            locationPill.textContent = "ç›®å‰ä½ç½®ï¼š" + addr;
          } else {
            locationPill.textContent = "ç›®å‰ä½ç½®ï¼šå·²å–å¾—å®šä½";
          }
        } catch {
          locationPill.textContent = "ç›®å‰ä½ç½®ï¼šå·²å–å¾—å®šä½";
        }
        runDailyPicks();
      }, (err) => {
        console.warn(err);
        locationPill.textContent = "ç›®å‰ä½ç½®ï¼šä¸å…è¨±å®šä½ï¼Œæˆ‘æ€éº¼æ¨è–¦å•¦ï¼Ÿ";
        dailyStatus.textContent = "è«‹é–‹å•Ÿå®šä½æ¬Šé™å¾Œé‡æ–°æ•´ç†é é¢ï¼Œæˆ–é»ä¸Šæ–¹æ–‡å­—æ‰‹å‹•è¼¸å…¥ä½ç½®ã€‚";
      }, {
        enableHighAccuracy: true,
        timeout: 8000,
        maximumAge: 0
      });
    }

    function bindEvents() {
      document.querySelectorAll(".chip[data-mode]").forEach(chip => {
        chip.addEventListener("click", () => {
          const mode = chip.dataset.mode;
          document.querySelectorAll(`.chip[data-mode="${mode}"]`).forEach(c => c.classList.remove("active"));
          chip.classList.add("active");
          runMealMode(mode);
        });
      });

      document.querySelectorAll(".chip[data-duty]").forEach(chip => {
        chip.addEventListener("click", () => {
          document.querySelectorAll(".chip[data-duty]").forEach(c => c.classList.remove("active"));
          chip.classList.add("active");
          runDutyMode(chip.dataset.duty);
        });
      });

      document.querySelectorAll(".chip[data-drink]").forEach(chip => {
        chip.addEventListener("click", () => {
          chip.classList.toggle("active");
        });
      });

      document.getElementById("btnWalk").addEventListener("click", () => runMealMode("walk"));
      document.getElementById("btnDrive").addEventListener("click", () => runMealMode("drive"));
      document.getElementById("btnDuty").addEventListener("click", () => runDutyMode());
      document.getElementById("btnDrink").addEventListener("click", () => runDrinkMode());

      // é»ä½ç½®è† å›Š â†’ æ‰‹å‹•è¼¸å…¥åœ°å€ / åœ°æ¨™
      locationPill.addEventListener("click", async () => {
        if (!geocoder) {
          alert("åœ°åœ–æœå‹™åˆå§‹åŒ–ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦ä¸€æ¬¡ã€‚");
          return;
        }
        const input = prompt("è«‹è¼¸å…¥åœ°å€æˆ–åœ°æ¨™ï¼ˆä¾‹å¦‚ï¼šå°ä¸­å¸‚è¥¿å±¯å€é€¢ç”²å¤œå¸‚ï¼‰ï¼š");
        if (!input || !input.trim()) return;
        const query = input.trim();
        try {
          locationPill.textContent = "ç›®å‰ä½ç½®ï¼šæŸ¥è©¢ä¸­â€¦";
          const { results } = await geocoder.geocode({ address: query });
          if (results && results[0]) {
            const r = results[0];
            const loc = r.geometry.location;
            const lat = typeof loc.lat === "function" ? loc.lat() : loc.lat;
            const lng = typeof loc.lng === "function" ? loc.lng() : loc.lng;
            userLocation = { lat, lng };
            const addrText = r.formatted_address || query;
            locationPill.textContent = "ç›®å‰ä½ç½®ï¼š" + addrText;
            runDailyPicks();
            walkStatus.textContent = "";
            driveStatus.textContent = "";
            drinkStatus.textContent = "";
          } else {
            locationPill.textContent = "ç›®å‰ä½ç½®ï¼šæŸ¥ç„¡æ­¤åœ°å€ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚";
          }
        } catch (e) {
          console.error(e);
          locationPill.textContent = "ç›®å‰ä½ç½®ï¼šæ‰‹å‹•å®šä½å¤±æ•—ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚";
        }
      });
    }

    window.addEventListener("load", () => {
      bindEvents();
      initMapAndLocation();
    });
  </script>
</body>
</html>
